#include "all.h"

/*
 *	This is the default command mode.
 */

struct mode_default {
	command command;
	int variant, value, is_hex;
};

static void command_handler(struct view *, unsigned);

/*
 *	The Escape character (0x1b, ^[) is generated by actual
 *	user keypresses, as a prefix to indicate the Alt key
 *	modifier, as part of a function key response, and as
 *	a response to a terminal query sequence.  Decode the
 *	function keys here, and treat other sequences as if
 *	they had been control character commands.  This allows
 *	Escape and Alt to be used as if they were Control.
 */

static int escape(struct view *view)
{
	int ch;

	switch ((ch = view_getch(view))) {
	case '[':
		ch = view_getch(view);
		if (isdigit(ch)) {
			int ok = view_getch(view) == '~';
			switch (ch) {
			case '5': window_page_up(view); break;
			case '6': window_page_down(view); break;
			case '2': /*INS*/
			case '3': /*DEL*/
			default: return 0;
			}
			return ok;
		} else {
			unsigned cursor = locus_get(view, CURSOR);
			switch (ch) {
			case 'D': cursor -= !!cursor; break;
			case 'C': cursor++; break;
			default: return 0;
			}
			locus_set(view, CURSOR, cursor);
		}
		break;
	case 'O':
		switch (view_getch(view)) {
		case 'H': locus_set(view, CURSOR, 0); break;
		case 'F': locus_set(view, CURSOR, view->bytes); break;
		default: return 0;
		}
		break;
	case '@':
	case ' ':
		command_handler(view, '\0');
		break;
	case '\\':
	case ']':
	case '^':
	case '_':
		command_handler(view, ch-'@');
		break;
	case '/':
		command_handler(view, '_'-'@');
		break;
	case '?':
		command_handler(view, '\x7f');
		break;
	case '\x1b': /* ESC ESC */
		break;
	default:
		if (ch >= 'a' && ch <= 'z')
			command_handler(view, ch-'a'+'A'-'@');
		else
			return 0;
		break;
	}

	return 1;
}

static unsigned cut(struct view *view, int delete)
{
	struct mode_default *mode = (struct mode_default *) view->mode;
	unsigned offset;
	int append;
	int bytes = view_get_selection(view, &offset, &append);

	if (!mode->variant)
		clip_init();
	clip(view, offset, bytes, append);
	if (delete)
		view_delete(view, offset, bytes);
	locus_set(view, MARK, UNSET);
	return offset;
}

static void align(struct view *view)
{
	unsigned cursor = locus_get(view, CURSOR);
	unsigned lnstart0 = find_line_start(view, cursor);
	unsigned nonspace0, lnstart, nonspace, lnend, chlen;
	int ch;
	char *indentation;
	unsigned indent_bytes;

	if (!lnstart0)
		return;
	for (nonspace0 = lnstart0;
	     (ch = view_unicode(view, nonspace0, &chlen)) >= 0;
	     nonspace0 += chlen)
		if (ch == '\n' || (ch != ' ' && ch != '\t'))
			break;
	lnstart = find_line_start(view, lnstart0-1);
	while (lnstart && view_unicode(view, lnstart, &chlen) == '\n')
		lnstart = find_line_start(view, lnstart-1);
	nonspace = lnstart;
	while ((ch = view_unicode(view, nonspace, &chlen)) != '\n' &&
	       (ch == ' ' || ch == '\t'))
		nonspace += chlen;
	indent_bytes = nonspace - lnstart;
	lnend = find_line_end(view, lnstart);
	indentation = allocate(NULL, lnend - lnstart);
	view_get(view, indentation, lnstart, indent_bytes);
	if ((ch = view_unicode_prior(view, lnend, NULL)) != ';' &&
	    ch != '}')
		indentation[indent_bytes++] = '\t';
	view_delete(view, lnstart0, nonspace0 - lnstart0);
	view_insert(view, indentation, lnstart0, indent_bytes);
	allocate(indentation, 0);
}

static void command_handler(struct view *view, unsigned ch)
{
	struct mode_default *mode = (struct mode_default *) view->mode;
	unsigned cursor = locus_get(view, CURSOR);
	unsigned mark = locus_get(view, MARK);
	char buf[8];
	int ok = 1, literal_unicode = 0;
	unsigned offset;
	struct view *new_view;
	char *path;

	/* Backspace always deletes the character before cursor. */
	if (ch == 0x7f /*BCK*/) {
		if (view_unicode_prior(view, cursor, &mark) >= 0)
			view_delete(view, mark, cursor-mark);
		else
			window_beep(view);
		goto done;
	}

	/* Non-control characters are self-inserted, with a prior
	 * automatic cut of the selection if one exists and the cursor
	 * is at its beginning.  But if we're in a variant, some
	 * characters may contribute to the value, or be non-Control
	 * commands.
	 */
	if (ch >= ' ' /*0x20*/) {

		if (mode->variant) {
			if (mode->is_hex && isxdigit(ch)) {
				mode->value *= 16;
				if (isdigit(ch))
					mode->value += ch - '0';
				else
					mode->value += tolower(ch) - 'a';
				return;
			}
			if (isdigit(ch)) {
				mode->value *= 10;
				mode->value += ch - '0';
				return;
			}
			if (!mode->value && (ch == 'x' || ch == 'X')) {
				mode->is_hex = 1;
				return;
			}
			switch (ch) {
			case '=':
				bookmark_set(mode->value, view, cursor, mark);
				goto done;
			case '-':
				if (bookmark_get(&new_view, &cursor, &mark,
						 mode->value)) {
					locus_set(new_view, CURSOR, cursor);
					if (mark != UNSET)
						locus_set(new_view, MARK, mark);
					window_activate(new_view);
				} else
					ok = 0;
				goto done;
			case ';':
				window_after(view, text_new(), -1);
				goto done;
			}
		}

		/* self insertion or replacement */
self_insert:	if (mark != UNSET && mark > cursor) {
			cursor = cut(view, 1);
			mark = UNSET;
		}
		if (ch <= 0x100 && !literal_unicode) {
			buf[0] = ch;
			view_insert(view, buf, cursor, 1);
		} else
			view_insert(view, buf, cursor, utf8_out(buf, ch));
		if (mark == cursor)
			locus_set(view, MARK, /*old*/ cursor);
		goto done;
	}

	/* Control character commands */
	switch ((ch += '@')) {
	case '@': /* (^Space) */
		if (mode->variant)
			break; /* unset variant */
		mode->variant = 1;
		return;
	case 'A': /* macro end/execute [start] */
		if (mode->variant) {
			view->macro_alloc = 64;
			view->macro = allocate(view->macro, view->macro_alloc);
			view->macro_bytes = 0;
			view->macro_at = 1; /* recording */
		} else if (view->macro && view->macro_bytes)
			if (view->macro_at == view->macro_bytes + 1)
				view->macro_at = --view->macro_bytes;
			else
				view->macro_at = 0; /* replay */
		else
			window_beep(view);
		break;
	case 'B': /* exchange clipbuffer and selection, if any, else paste */
		if (mark != UNSET) {
			int outbytes = view_get_selection(view, &offset, NULL);
			int inbytes = clip_paste(view, offset + outbytes);
			clip_init();
			clip(view, offset, outbytes, 0);
			view_delete(view, offset, outbytes);
			locus_set(view, CURSOR, offset);
			locus_set(view, MARK, offset + inbytes);
		} else {
			clip_paste(view, cursor);
			locus_set(view, MARK, /*old*/ cursor);
		}
		break;
	case 'C': /* forward to line end */
		if ((offset = find_line_end(view, cursor)) == cursor)
			offset = find_line_end(view, cursor+1);
		locus_set(view, CURSOR, offset + (offset == cursor));
		break;
	case 'D': /* [select whitespace] / cut [pre/appending] */
		if (mark == UNSET && mode->variant) {
			mark = cursor;
			while (cursor &&
			       ((ch = view_byte(view, cursor-1)) == ' ' ||
				ch == '\t' || ch == '\n'))
				--cursor;
			while (mark < view->bytes &&
			       ((ch = view_byte(view, mark)) == ' ' ||
				ch == '\t' || ch == '\n'))
				mark++;
			locus_set(view, CURSOR, cursor);
			locus_set(view, MARK, mark);
		} else
			cut(view, 1);
		break;
	case 'E':
		if (mark == UNSET && mode->variant)
			demultiplex_view(view);
		else
			mode_child(view);
		break;
	case 'F': /* copy [pre/appending] */
		cut(view, 0);
		break;
	case 'G': /* backward line */
		locus_set(view, CURSOR, find_line_start(view, cursor - !!cursor));
		break;
	case 'H': /* backward char(s) */
		if (mode->value && mode->value <= cursor)
			cursor -= mode->value;
		else
			cursor -= !!cursor;
		locus_set(view, CURSOR, cursor);
		break;
	case 'I': /* (TAB) tab / tab completion [align; set tab stop] */
		if (!mode->variant) {
			char *completed;
			path = NULL;
			if (mark < cursor &&
			    (path = view_extract_selection(view)) &&
			    (completed = tab_complete(path))) {
				view_delete_selection(view);
				view_insert(view, completed, mark, -1);
				locus_set(view, MARK, mark);
				allocate(path, 0);
				allocate(completed, 0);
			} else {
				allocate(path, 0);
				ch = '\t';
				goto self_insert;
			}
		} else if (mode->value)
			if (mode->value >= 1 && mode->value <= 20)
				view->text->tabstop =
					default_tab_stop = mode->value;
			else
				window_beep(view);
		else
			align(view);
		break;
	case 'J':
		view_insert(view, "\n", cursor++, 1);
		align(view);
		break;
	case 'K': /* save all [single] */
		if (mode->variant)
			text_preserve(view->text);
		else
			texts_preserve();
		break;
	case 'L': /* forward screen [end of view] */
		if (mode->variant)
			locus_set(view, CURSOR, view->bytes);
		else
			window_page_down(view);
		break;
	case 'M': /* (ENT) new line [opened] */
		if (mode->variant) {
			view_insert(view, "\n", cursor, 1);
			locus_set(view, CURSOR, cursor);
			break;
		}
		ch = '\n';
		goto self_insert;
	case 'N': /* backward word(s) [sentence] */
		if (mode->value)
			while (mode->value--)
				cursor = find_word_start(view, cursor);
		else if (mode->variant)
			cursor = find_sentence_start(view, cursor);
		else
			cursor = find_word_start(view, cursor);
		locus_set(view, CURSOR, cursor);
		break;
	case 'O':
		window_beep(view);
		break;
	case 'P': /* select other window [closing current] */
		(mode->variant ? window_unmap : window_next)(view);
		break;
	case 'Q': /* suspend [quit] */
		windows_end();
		if (mode->variant) {
			texts_preserve();
			while (text_list)
				view_close(text_list->views);
			exit(EXIT_SUCCESS);
		}
		fprintf(stderr, "The editor is suspended.  "
			"Type 'fg' to resume.\n");
		kill(getpid(), SIGSTOP);
		window_recenter(view);
		break;
	case 'R': /* backward screen [beginning of view] */
		if (mode->variant)
			locus_set(view, CURSOR, 0);
		else
			window_page_up(view);
		break;
	case 'S': /* forward word(s) [sentence] */
		if (mode->value)
			while (mode->value--)
				cursor = find_word_end(view, cursor);
		else if (mode->variant)
			cursor = find_sentence_end(view, cursor);
		else
			cursor = find_word_end(view, cursor);
		locus_set(view, CURSOR, cursor);
		break;
	case 'T': /* forward char(s) */
		if (mode->value)
			cursor += mode->value;
		else
			cursor++;
		locus_set(view, CURSOR, cursor);
		break;
	case 'U': /* undo [redo] */
		offset = (mode->variant ? text_redo :
					  text_undo)(view->text);
		if ((offset -= view->start) <= view->bytes)
			locus_set(view, CURSOR, offset);
		locus_set(view, MARK, UNSET);
		break;
	case 'V': /* set/unset mark [exchange, or select line] */
		if (!mode->variant)
			locus_set(view, MARK, mark == UNSET ? cursor : UNSET);
		else if (mark == UNSET) {
			locus_set(view, MARK, find_line_end(view, cursor) + 1);
			locus_set(view, CURSOR, find_line_start(view, cursor));
		} else {
			locus_set(view, MARK, cursor);
			locus_set(view, CURSOR, mark);
		}
		break;
	case 'W': /* select other view [closing current] */
		if (mode->variant)
			view_close(view);
		else if (!window_replace(view, view_next(view)))
			window_beep(view);
		break;
	case 'X': /* get path / visit file [set path] */
		if (mark == UNSET) {
			view_insert(view, view->text->path, cursor, -1);
			locus_set(view, MARK, /*old*/ cursor);
		} else if ((path = view_extract_selection(view))) {
			if (mode->variant) {
				if ((ok = text_rename(view->text, path)))
					window_activate(view);
				new_view = NULL;
			} else
				ok = !!(new_view = view_open(path));
			allocate(path, 0);
			if (ok)
				view_delete_selection(view);
			if (new_view)
				window_after(view, new_view, -1 /*auto*/);
		}
		break;
	case 'Y': /* split window [vertically] */
		if (mark != UNSET) {
			unsigned offset = mark < cursor ? mark : cursor;
			unsigned bytes = mark < cursor ? cursor - mark :
					 mark - cursor;
			new_view = view_selection(view, offset, bytes);
		} else
			new_view = view_next(view);
		if (new_view)
			window_after(view, new_view, mode->variant);
		else
			window_beep(view);
		break;
	case 'Z': /* recenter/goto */
		if (mode->value) {
			cursor = 0;
			while (--mode->value)
				cursor = find_line_end(view, cursor) + 1;
			locus_set(view, CURSOR, cursor);
		} else if (mode->variant)
			windows_reset();
		window_recenter(view);
		break;
	case '[': /* ESC */
		ok &= escape(view);
		break;
	case '\\': /* quit */
		windows_end();
		texts_uncreate();
		exit(EXIT_SUCCESS);
		break;
	case ']': /* set mark and move to corresponding bracket */
		mark = view_corresponding_bracket(view, cursor);
		if ((signed) mark < 0)
			window_beep(view);
		else {
			locus_set(view, CURSOR, mark + (mark > cursor));
			locus_set(view, MARK, cursor + (mark < cursor));
		}
		break;
	case '^': /* literal [; unicode] */
		if (mode->value) {
			ch = mode->value;
			literal_unicode = 1;
			goto self_insert;
		}
		if ((signed) (ch = view_getch(view)) >= 0) {
			if (ch >= '@' && ch <= '_')
				ch -= '@';
			else if (ch >= 'a' && ch <= 'z')
				ch -= 'a'-1;
			else if (ch == '?')
				ch = 0x7f;
			goto self_insert;
		}
		ok = 0;
		break;
	case '_': /* ^/: search */
		mode_search(view);
		break;
	default:
		ok = 0;
		break;
	}

done:	mode->variant = mode->value = mode->is_hex = 0;
	if (!ok)
		window_beep(view);
}

struct mode *mode_default(void)
{
	struct mode_default *dft = allocate(NULL, sizeof *dft);
	memset(dft, 0, sizeof *dft);
	dft->command = command_handler;
	return (struct mode *) dft;
}
